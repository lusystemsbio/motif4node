#' Scatterplots of PCA and Gene expression from any 4-node circuit
#' @param rset The sRACIPE object of the simulated circuit
#' @return list(g,p)
#' @import sRACIPE
#' @import SummarizedExperiment
#' @export
plot_RACIPE <- function(rset){
  
  gex = log2(t(assay(rset)))
  gex.1  = ggplot(data = as.data.frame(gex), aes_string(x = "A", y = "B")) +
    geom_point() +
    theme_classic()
  
  gex.2  = ggplot(data = as.data.frame(gex), aes_string(x = "A", y = "C")) +
    geom_point() +
    theme_classic()
  
  gex.3  = ggplot(data = as.data.frame(gex), aes_string(x = "A", y = "D")) +
    geom_point() +
    theme_classic()
  
  gex.4  = ggplot(data = as.data.frame(gex), aes_string(x = "B", y = "C")) +
    geom_point() +
    theme_classic()
  
  gex.5  = ggplot(data = as.data.frame(gex), aes_string(x = "B", y = "D")) +
    geom_point() +
    theme_classic()
  
  gex.6  = ggplot(data = as.data.frame(gex), aes_string(x = "C", y = "D")) +
    geom_point() +
    theme_classic()
  g = plot_grid(gex.1, gex.2, gex.3, gex.4, gex.5, gex.6)
  pca = prcomp(gex, center = T, scale = T)
  eigs = pca$sdev^2
  eigs = eigs / sum(eigs)
  pca.1  = ggplot(data = as.data.frame(pca$x), aes_string(x = "PC1", y = "PC2")) +
    geom_point() +
    theme_classic() +
    labs( x = paste0("PC1 ",round(eigs[[1]],3)*100, "%" ), y =paste0("PC2 ",round(eigs[[2]],3)*100, "%" ) )
  
  pca.2 = ggplot(data = as.data.frame(pca$x), aes_string(x = "PC1", y = "PC3")) +
    geom_point() +
    theme_classic()+
    labs( x = paste0("PC1 ",round(eigs[[1]],3)*100, "%" ), y =paste0("PC3 ",round(eigs[[3]],3)*100, "%" ) )
  
  pca.3 = ggplot(data = as.data.frame(pca$x), aes_string(x = "PC1", y = "PC4")) +
    geom_point() +
    theme_classic()+
    labs( x = paste0("PC1 ",round(eigs[[1]],3)*100, "%" ), y =paste0("PC4 ",round(eigs[[4]],3)*100, "%" ) )
  
  pca.4 = ggplot(data = as.data.frame(pca$x), aes_string(x = "PC2", y = "PC3")) +
    geom_point() +
    theme_classic()+
    labs( x = paste0("PC2 ",round(eigs[[2]],3)*100, "%" ), y =paste0("PC3 ",round(eigs[[3]],3)*100, "%" ) )
  p = ggdraw() +
    draw_plot(pca.1, 0, .5, .5, .5) +
    draw_plot(pca.2, .5, .5, .5, .5) +
    draw_plot(pca.3, 0, 0, .5, .5) +
    draw_plot(pca.4, .5, 0, .5, .5)
  n =  plot_net(sracipeCircuit(rset))
  return(list(g,p,n))
}

#' Network plotting function
#' @param tf_links Data frame of circuit edge list. 
#' Three columns: Source, Target, Interaction Types -- 1: Activation; 2: Inhibition
#' @return empty
#' @import visNetwork
#' @export
plot_net <- function(tf_links = tf_links){
  tf_links <- tf_links[which(tf_links[,3] !=0),]
  topology=data.frame(as.matrix(tf_links), stringsAsFactors = F)
  node_list <- unique(c(topology[,1], topology[,2]))
  nodes <- data.frame(id = node_list,  font.size =30, value=c(rep(1,length(node_list))))
  label <- as.character(nodes$id)
  nodes <- cbind(nodes, label)
  edge_col <- data.frame(c(1,2),c("blue","darkred"))
  colnames(edge_col) <- c("relation", "color")
  arrow_type <- data.frame(c(1,2),c("arrow","circle"))
  colnames(arrow_type) <- c("type", "color")
  edges <- data.frame(from =c(topology[,1]), to = c(topology[,2])
                      , arrows.to.type	=arrow_type$color[c(as.numeric(topology[,3]))]
                      , width = 3
                      , color = edge_col$color[c(as.numeric(topology[,3]))]
  )
  visNetwork(nodes, edges, height = "1000px", width = "100%") %>%
    visEdges(arrows = "to") %>%
    visOptions(manipulation = F) %>%
    visLayout(randomSeed = 123) %>%
    visNodes(scaling = list(label = list(enabled = F))) %>%
    visPhysics(solver = "forceAtlas2Based", stabilization = FALSE)%>%
    visNodes(size = 10)
}

#' Plot a specific circuit motif
#' @param number Integer. Index of a two-node circuit motif
#' @param motif_list List of 2 by 2 integer matrix. 2-node motif info generated by the function: generate_motif_list.
#' @return empty
#' @export
plot_motif <- function(number, motif_list){
  tmp <- get_motif(number, motif_list)
  Source <- tmp$from
  Target <- tmp$to
  Type <- tmp$color
  tmp <- as.data.frame(cbind(Source,Target,Type))
  i.r <- which(tmp$Type == "red")
  i.b <- which(tmp$Type == "blue")
  Type <- vector(length = sum(length(i.r),length(i.b)))
  Type[i.r] <- 2
  Type[i.b] <- 1
  tmp$Type <- Type
  plot_net(tmp)
}

#' Plot a network from the adjacency matrix
#' @param adj Matrix (4 by 4, integer). Adjacency matrix of a four node circuit.
#' @return empty
#' @export
plot_adj <- function(adj){
  tmp2 <- as.data.frame(matrix(ncol = 3))
  colnames(tmp2) <- c("from", "to", "arrows.to.type")
  k <- 0
  for (i in 1:ncol(adj)){
    for (j in 1:ncol(adj)){
      if (adj[[i,j]] == 1){
        k <- k+1
        tmp2[k,1] <- colnames(adj)[j]
        tmp2[k,2] <- rownames(adj)[i]
        tmp2[k,3] <- 1
      } else if(adj[[i,j]] == 2){
        k <- k+1
        tmp2[k,1] <- colnames(adj)[j]
        tmp2[k,2] <- rownames(adj)[i]
        tmp2[k,3] <- 2
      }else if(adj[[i,j]] == 0){
        k <- k+1
        tmp2[k,1] <- colnames(adj)[j]
        tmp2[k,2] <- rownames(adj)[i]
        tmp2[k,3] <- 0
      }
    }
  }
  plot_net(tmp2)
}

# Save pheatmap plot to PDF
#' @import grDevices
save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
  stopifnot(!missing(x))
  stopifnot(!missing(filename))
  pdf(filename, width=width, height=height)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
